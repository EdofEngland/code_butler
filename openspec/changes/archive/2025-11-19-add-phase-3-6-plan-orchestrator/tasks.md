## 1. Implementation
- [x] 1.1 Implement planner dispatch.
  - [x] 1.1.1 Add `ai_clean/planners/orchestrator.py` defining `plan_from_finding(finding: Finding, *, chunk_index: int = 0) -> CleanupPlan`.
  - [x] 1.1.2 Create a category-to-function map that routes `duplicate_block`, `large_file`, `long_function`, `missing_docstring`, `weak_docstring`, `organize_candidate`, and `advanced_cleanup` to the planner helpers introduced in phase 3 tasks.
  - [x] 1.1.3 For duplicate findings, call `duplicate._chunk_occurrences` first and pass the requested chunk to `plan_duplicate_block` so the orchestrator still returns exactly one plan.
- [x] 1.2 Add plan ID and persistence helpers.
  - [x] 1.2.1 Implement `_generate_plan_id(finding: Finding, chunk_index: int) -> str` that produces deterministic kebab-case IDs combining category, sanitized path, and chunk index.
  - [x] 1.2.2 Add `save_plan(plan: CleanupPlan, config: AiCleanConfig) -> Path` that writes JSON under `.ai-clean/plans/{plan.id}.json` and ensures directories exist.
  - [x] 1.2.3 Update the orchestrator to call `save_plan` before returning and to attach the saved path inside `plan.metadata["stored_at"]`.
- [x] 1.3 Guarantee a single CleanupPlan output and consistent schema.
  - [x] 1.3.1 Normalize every plan via `CleanupPlan.from_dict(plan.to_dict())` before returning to ensure serialization round-trips.
  - [x] 1.3.2 Add validation that raises a descriptive `ValueError` if a category lacks a planner or if required metadata (e.g., duplicate occurrences) is missing, preventing partially filled plans from being persisted.
