## 1. Implementation
- [x] 1.1 Implement branch helper to create/fast-forward and checkout the refactor branch from base.
  - [x] 1.1.1 Add `ai_clean/git_helpers.py` exporting `ensure_on_refactor_branch(base_branch: str, refactor_branch: str) -> None` plus a private `_run_git(args: Sequence[str])` wrapper using `subprocess.run(..., capture_output=True, text=True)`.
  - [x] 1.1.2 Inside the helper, determine the current branch via `git rev-parse --abbrev-ref HEAD` and immediately return when it already matches `refactor_branch`.
  - [x] 1.1.3 Fetch the latest base tip with `git fetch origin <base_branch>` and record stderr/stdout for troubleshooting in raised errors.
  - [x] 1.1.4 If the refactor branch is missing (`git rev-parse --verify <refactor_branch>` fails), create it via `git branch <refactor_branch> origin/<base_branch>`.
  - [x] 1.1.5 Checkout the refactor branch (`git checkout <refactor_branch>`) and fast-forward it with `git merge --ff-only origin/<base_branch>` so it matches base history.
- [x] 1.2 Avoid auto-commits or merges into main and report conflicts to the user.
  - [x] 1.2.1 Ensure `_run_git` surfaces non-zero return codes as `GitError` with the command plus captured stderr; do not attempt to resolve conflicts automatically.
  - [x] 1.2.2 When the fast-forward fails (non-fast-forward merge or conflicts), bubble the git error back to callers so they can fix it manually—never run `git merge` into `base_branch`.
  - [x] 1.2.3 Add docstrings/comments documenting that the helper only manipulates the requested refactor branch and never changes `base_branch` directly.
- [x] 1.3 No-op when already on the refactor branch.
  - [x] 1.3.1 Cover this in unit tests by monkeypatching `_run_git` to record commands; verify that only the `rev-parse` call happens when the current branch equals `refactor_branch`.
  - [x] 1.3.2 Add broader tests proving the command sequence for the “branch exists” and “branch missing” cases, asserting no git command attempts to commit or merge into main.
