"""CLI entrypoint for ai-clean."""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from typing import Callable

from ai_clean.analyzers import analyze_repo
from ai_clean.commands.advanced_cleanup import run_advanced_cleanup
from ai_clean.metadata import ensure_metadata_dirs
from ai_clean.models import Finding

CommandHandler = Callable[[argparse.Namespace], int]


_COMMAND_SPECS: tuple[tuple[str, str], ...] = (
    ("analyze", "Scan a project and propose cleanup plans"),
    ("clean", "Execute previously approved cleanup plans"),
    ("annotate", "Generate docstring improvement plans"),
    ("organize", "Suggest file moves and project structure fixes"),
    ("cleanup-advanced", "Run advanced Codex-driven cleanup flows"),
    ("plan", "Author a new ButlerSpec plan for a specific target"),
    ("apply", "Apply a ButlerSpec plan using Codex"),
    ("changes-review", "Review executed plans and summarize risks"),
)


def _make_handler(command_label: str) -> CommandHandler:
    def _handler(_: argparse.Namespace) -> int:
        print(f"TODO: /{command_label}")
        return 0

    return _handler


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="ai-clean",
        description=(
            "ButlerSpec-governed cleanup assistant. Commands mirror the "
            "Phase 1 system sketch (plan → spec → apply)."
        ),
    )
    subparsers = parser.add_subparsers(dest="command", metavar="command")

    for command_name, help_text in _COMMAND_SPECS:
        subparser = subparsers.add_parser(command_name, help=help_text)
        if command_name == "analyze":
            subparser.add_argument(
                "--root",
                default=".",
                help="Path to the repository root (defaults to current directory)",
            )
            subparser.add_argument(
                "--config",
                default=None,
                help="Optional ai-clean configuration file to load",
            )
            subparser.add_argument(
                "--json",
                action="store_true",
                help="Emit findings as JSON instead of a text table",
            )
            subparser.set_defaults(handler=_run_analyze_command)
            continue
        if command_name == "cleanup-advanced":
            subparser.add_argument(
                "--root",
                default=".",
                help="Path to the repository root (defaults to current directory)",
            )
            subparser.add_argument(
                "--config",
                default=None,
                help="Optional ai-clean configuration file to load",
            )
            subparser.add_argument(
                "--findings-json",
                required=True,
                help="Path to findings JSON generated by `ai-clean analyze --json`",
            )
            subparser.add_argument(
                "--json",
                action="store_true",
                help="Emit findings as JSON instead of a text table",
            )
            subparser.set_defaults(handler=_run_cleanup_advanced_command)
            continue
        subparser.set_defaults(handler=_make_handler(command_name))

    return parser


def main(argv: list[str] | None = None) -> int:
    ensure_metadata_dirs()
    parser = _build_parser()
    args = parser.parse_args(argv)
    handler: CommandHandler | None = getattr(args, "handler", None)
    if handler is None:
        parser.print_help()
        return 0
    return handler(args)


if __name__ == "__main__":
    raise SystemExit(main())


def _run_analyze_command(args: argparse.Namespace) -> int:
    root = Path(args.root).expanduser().resolve()
    config_path = _resolve_config_path(root, args.config)
    try:
        findings = analyze_repo(root, config_path)
    except FileNotFoundError as exc:
        print(f"Failed to load configuration: {exc}", file=sys.stderr)
        return 1
    except Exception as exc:  # pragma: no cover - defensive
        print(f"Unexpected error while running analyzers: {exc}", file=sys.stderr)
        return 1

    return _print_findings(findings, args.json)


def _run_cleanup_advanced_command(args: argparse.Namespace) -> int:
    root = Path(args.root).expanduser().resolve()
    config_path = _resolve_config_path(root, args.config)
    findings_path = Path(args.findings_json).expanduser().resolve()
    try:
        findings = run_advanced_cleanup(root, config_path, findings_path)
    except FileNotFoundError as exc:
        print(f"Failed to load configuration or findings: {exc}", file=sys.stderr)
        return 1
    except Exception as exc:  # pragma: no cover - defensive
        print(
            f"Unexpected error while running advanced cleanup: {exc}", file=sys.stderr
        )
        return 1

    return _print_findings(findings, args.json)


def _print_findings(findings: list[Finding], as_json: bool) -> int:
    if as_json:
        payload = [finding.model_dump(mode="json") for finding in findings]
        print(json.dumps(payload, indent=2))
        return 0

    if not findings:
        print("No findings detected.")
        return 0

    for finding in findings:
        print(f"{finding.id} | {finding.category} | {finding.description}")
        for location in finding.locations:
            rel_path = location.path.as_posix()
            print(f"  - {rel_path}:{location.start_line}-{location.end_line}")
    return 0


def _resolve_config_path(root: Path, config_arg: str | None) -> Path | None:
    if config_arg:
        return Path(config_arg).expanduser().resolve()
    return root / "ai-clean.toml"
